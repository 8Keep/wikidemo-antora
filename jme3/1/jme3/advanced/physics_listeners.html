<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Physics Listeners :: jMonkeyEngine Documentation</title>
    <link rel="canonical" href="https://8keep.github.io/wikidemo-antora/jme3/1/jme3/advanced/physics_listeners.html">
    <meta name="keywords" content="documentation, physics, collision, forces, interaction">
    <meta name="generator" content="Antora 2.3.0">
    <link rel="stylesheet" href="../../../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://8keep.github.io/wikidemo-antora">jMonkeyEngine Documentation</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Resource A</a>
            <a class="navbar-item" href="#">Resource B</a>
            <a class="navbar-item" href="#">Resource C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="jme3" data-version="1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../documentation.html">Test</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../documentation.html">jMonkeyEngine 3</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Test</span>
    <span class="version">1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Test</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../documentation.html">1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../documentation.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../documentation.html">Test</a></li>
    <li><a href="physics_listeners.html">Physics Listeners</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="file:///home/davisro/dev/wikidemo-antora/docs/modules/ROOT/pages/jme3/advanced/physics_listeners.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<article class="doc">
<h1 class="page">Physics Listeners</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>You can control physical objects (push them around) by applying physical forces to them. Typically, you also want to respond to the resulting collisions, e.g. by substracting health points or by playing a sound. To specify how the game responds to such physics events, you use Physics Listeners.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sample_code"><a class="anchor" href="#_sample_code"></a>Sample Code</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/TestCollisionListener.java">TestCollisionListener.java</a></p>
</li>
<li>
<p><a href="https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/TestAttachGhostObject.java">TestAttachGhostObject.java</a></p>
</li>
<li>
<p><a href="https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/TestGhostObject.java">TestGhostObject.java</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_physicsghostobjects"><a class="anchor" href="#_physicsghostobjects"></a>PhysicsGhostObjects</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Attach a com.jme3.bullet.control.GhostControl to any Spatial to turn it into a PhysicsGhostObject. Ghost objects automatically follow their spatial and detect collisions. The attached ghost itself is invisible and non-solid (!) and doesn&#8217;t interfere with your game otherwise, it only passively reports collisions.</p>
</div>
<div class="paragraph">
<p>You can leave the GhostControl non-solid and invisible and attach it to an (invisible) Node in the scene to create something like a motion detector. But a GhostControl also works fine when added to spatials that are solid (with RigidBodyControl) and visible (with Geometry). One use case for GhostControls is to check for collisions among <a href="walking_character.html" class="page">CharacterControls</a> when the characters are walking.</p>
</div>
<div class="paragraph">
<p>The shape of the ghost depends on the CollisionShape that you gave the GhostControl. This means that the GhostControl&#8217;s shape can be different from the RigidBodyControl&#8217;s shape. For example, the non-solid ghost shape can be bigger than the solid shape of the Spatial (so you can “feel ahead).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">GhostControl ghost = new GhostControl(
  new BoxCollisionShape(new Vector3f(1,1,1)));  // a box-shaped ghost
Node node = new Node("a ghost-controlled thing");
node.addControl(ghost);                         // the ghost follows this node
// Optional: Add a Geometry, or other controls, to the node if you need to
...
// attach everything to activate it
rootNode.attachChild(node);
getPhysicsSpace().add(ghost);</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Ghost methods</th>
<th class="tableblock halign-left valign-top">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>getOverlappingObjects()</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Returns the List of objects that are currently colliding (overlapping) with the ghost.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>getOverlappingCount()</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Returns the number of currently colliding objects.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>getOverlapping(i)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Get PhysicsCollisionObject number i.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_physics_tick_listener"><a class="anchor" href="#_physics_tick_listener"></a>Physics Tick Listener</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The jBullet Physics implementation is stepped at a constant 60 physics ticks per second frame rate.
Applying forces or checking for overlaps only has an effect right at a physics update cycle, which is not every frame. If you do physics interactions at arbitrary spots in the simpleUpdate() loop, calls will be dropped at irregular intervals, because they happen out of cycle.</p>
</div>
<div class="sect2">
<h3 id="_when_not_to_use_tick_listener"><a class="anchor" href="#_when_not_to_use_tick_listener"></a>When (Not) to Use Tick Listener?</h3>
<div class="paragraph">
<p>When you write game mechanics that apply forces, you must implement a tick listener (com.jme3.bullet.PhysicsTickListener) for it. The tick listener makes certain the forces are not dropped, but applied in time for the next physics tick.</p>
</div>
<div class="paragraph">
<p>Also, when you check for overlaps of two physical objects using a GhostControl, you cannot just go <code>ghost.getOverLappingObjects()</code> somewhere outside the update loop. You have to make certain 1 physics tick has passed before the overlapping objects list is filled with data. Again, the PhysicsTickListener does the timing for you.</p>
</div>
<div class="paragraph">
<p>When your game mechanics however just poll the current state (e.g. getPhysicsLocation()) of physical objects, or if you only use the GhostControl like a sphere trigger inside an update loop, then you don&#8217;t need an extra PhysicsTickListener.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_listen_to_physics_ticks"><a class="anchor" href="#_how_to_listen_to_physics_ticks"></a>How to Listen to Physics Ticks</h3>
<div class="paragraph">
<p>Here&#8217;s is the declaration of an examplary Physics Control that listens to ticks. (The example shows a RigidBodyControl, but it can also be GhostControl.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyCustomControl
    extends RigidBodyControl implements PhysicsTickListener { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you implement the interface, you have to implement <code>physicsTick()</code> and <code>preTick()</code> methods.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>prePhysicsTick(PhysicsSpace space, float tpf)</code> is called before each step, here you apply forces (change the state).</p>
</li>
<li>
<p><code>physicsTick(PhysicsSpace space, float tpf)</code> is called after each step, here you poll the results (get the current state).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The tpf value is time per frame in seconds. You can use it as a factor to time actions so they run equally on slow and fast machines.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@override
public void prePhysicsTick(PhysicsSpace space, float tpf){
  // apply state changes ...
}
@override
public void physicsTick(PhysicsSpace space, float tpf){
  // poll game state ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_physics_collision_listener"><a class="anchor" href="#_physics_collision_listener"></a>Physics Collision Listener</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_when_not_to_use_collision_listener"><a class="anchor" href="#_when_not_to_use_collision_listener"></a>When (Not) to Use Collision Listener</h3>
<div class="paragraph">
<p>If you do not implement the Collision Listener interface (com.jme3.bullet.collision.PhysicsCollisionListener), a collisions will just mean that physical forces between solid objects are applied automatically. If you just want “Balls rolling, bricks falling you do not need a listener.</p>
</div>
<div class="paragraph">
<p>If however you want to respond to a collision event (com.jme3.bullet.collision.PhysicsCollisionEvent) with a custom action, then you need to implement the PhysicsCollisionListener interface. Typical actions triggered by collisions include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Increasing a counter (e.g. score points)</p>
</li>
<li>
<p>Decreasing a counter (e.g. health points)</p>
</li>
<li>
<p>Triggering an effect (e.g. explosion)</p>
</li>
<li>
<p>Playing a sound (e.g. explosion, ouch)</p>
</li>
<li>
<p>… and countless more, depending on your game</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_listen_to_collisions"><a class="anchor" href="#_how_to_listen_to_collisions"></a>How to Listen to Collisions</h3>
<div class="paragraph">
<p>You need to add the PhysicsCollisionListener to the physics space before collisions will be listened for. Here&#8217;s an example of a Physics Control that uses a collision listener. (The example shows a RigidBodyControl, but it can also be GhostControl.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyCustomControl extends RigidBodyControl
    implements PhysicsCollisionListener {
    public MyCustomControl() {
        bulletAppState.getPhysicsSpace().addCollisionListener(this);
        ...
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>To respond to the PhysicsCollisionEvent you now have to override the <code>collision()</code> method in MyCustomControl. This gives you access to the <code>event</code> object. Mostly you will be interested in the identity of any two nodes that collided: <code>event.getNodeA()</code> and <code>event.getNodeB()</code>.</p>
</div>
<div class="paragraph">
<p>After you identify the colliding nodes, specify the action to trigger when this pair collides. Note that you cannot know which one will be Node A or Node B, you have to deal with either variant.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    public void collision(PhysicsCollisionEvent event) {
        if ( event.getNodeA().getName().equals("player") ) {
            final Node node = event.getNodeA();
            /** ... do something with the node ... */
        } else if ( event.getNodeB().getName().equals("player") ) {
            final Node node = event.getNodeB();
            /** ... do something with the node ... */
        }
    }</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that after the collision() method ends, the PhysicsCollisionEvent is cleared. You must get all objects and values you need within the collision() method.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_reading_details_from_a_physicscollisionevent"><a class="anchor" href="#_reading_details_from_a_physicscollisionevent"></a>Reading Details From a PhysicsCollisionEvent</h3>
<div class="paragraph">
<p>The PhysicsCollisionEvent <code>event</code> gives you access to detailed information about the collision. You already know the event objects can identify which nodes collided, but it even knows how hard they collided:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-top">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>getObjectA()<br>
getObjectB()</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The two participants in the collision. You cannot know in advance whether some node will be recorded as A or B, you always have to consider both cases.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>getAppliedImpulse()</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A float value representing the collision impulse</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>getAppliedImpulseLateral1()</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A float value representing the lateral collision impulse</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>getAppliedImpulseLateral2()</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A float value representing the lateral collision impulse</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>getCombinedFriction()</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A float value representing the collision friction</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>getCombinedRestitution()</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A float value representing the collision restitution (bounciness)</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Note that after the collision method has been called the object is not valid anymore so you should copy any data you want to keep into local variables.</p>
</div>
</div>
<div class="sect2">
<h3 id="_collision_groups"><a class="anchor" href="#_collision_groups"></a>Collision Groups</h3>
<div class="paragraph">
<p>You can improve performance by resricting the number of tests that collision detection has to perform. If you have a case where you are only interested in collisions between certain objects but not others, you can assign sets of physical obejcts to different collision groups.</p>
</div>
<div class="paragraph">
<p>For example, for a click-to-select, you only care if the selection ray collides with a few selectable objects such as dropped weapons or powerups (one group), but not with non-selectables such as floors or walls (different group).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">myNode.getControl(RigidBodyControl.class).setCollisionGroup(PhysicsCollisionObject.COLLISION_GROUP_02);
myNode.getControl(RigidBodyControl.class).setCollideWithGroups(PhysicsCollisionObject.COLLISION_GROUP_02);</code></pre>
</div>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../../_/js/site.js"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
